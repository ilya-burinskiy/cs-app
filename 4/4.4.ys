  .pos 0
  irmovq stack, %rsp
  call main
  halt

  .align 8
array:
  .quad 0x000000000001
  .quad 0x000000000002
  .quad 0x000000000003
  .quad 0x000000000004

main:
  irmovq array, %rdi
  irmovq $4, %rsi
  call mult 
  ret

product:
  irmovq $1, %rax         # rax = 1
  andq %rsi, %rsi
  je product_done         # if n == 0 goto done
  mrmovq (%rdi), %rdx     # rdx = *arr
  irmovq $8, %rcx         # rcx = 8
  addq %rcx, %rdi         # arr = arr + 8
  subq %rax
  call product            # rax = product(arr + 8, n - 1)
  rrmovq %rax, %rdi       # rdi = rax
  rrmovq %rdx, %rsi       # rsi = *arr
  call mult               # rax = *arr * product(arr + 8, n - 1)
product_done:
  ret

# 7 * 2 = 7 + 7
# a in rdi
# b in rsi
# if (a == 0 || b == 0) { return 0; }
# res = a
# b = b - 1
# while (b != 0) {
#   res = res + a;
#   b--
# }
# return res;
mult:
  irmovq $0, %rax         # res = 0
  andq %rdi, %rdi        # test a
  je mult_done           # if (a == 0) return res
  andq %rsi, %rsi        # test b
  je mult_done           # if (b == 0) return res
  irmovq $1, %rdx        # rdx = 1
mult_loop:
  addq %rdi, %rax        # res = res + a
  subq %rdx, %rsi        # b = b - 1
  andq %rsi, %rsi        # test b
  jne mult_loop
mult_done:
  ret

  .pos 0x200
stack:
